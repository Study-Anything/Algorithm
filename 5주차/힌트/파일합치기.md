(다시 작성할 예정)

예시로 이해해보자.

파일의 크기가 [40, 30, 30, 50] 이라고 가정하자.

어떤 전략을 세울 수 있을까?

그냥 저 파일 중에서 가장 작은 파일 끼리 합치면 어떨까?

그러면

30 과 30 을 합쳐서 X1 을 만들 수 있고 (비용:60)
X1 과 40 을 합쳐서 X2 를 만들 수 있고 (비용:100)
X2 와 50 을 합칠 수 있다. (비용:150)
- 전체 비용은 60 + 100 + 150 = 310 이다.

이 방법은 최적의 해를 이끌어내지 못하며, 아래와 같은 상황이 예외가 된다.

40 과 30 을 합쳐서 Y1 을 만들고 (비용:70)
30 과 50 을 합쳐서 Y2 을 만들고 (비용:80)
Y1 과 Y2 를 합친다. (비용:150)
- 전체 비용은 70 + 80 + 150 = 300 < 310

즉, 현재 상황에서 가장 작은 파일끼리 합치는 전략은 항상 TRUE 임을 보장하지 못한다.

```
참고로 이와 같이 현재 주어진 상황에서 봤을 때 가장 좋은 선택을 해나가는 전략은 Greedy Algorithm 이라고 따로 부른다.
```

그러면 결국 모든 경우를 다 살펴보아야 할 것 같은데...

생각해보면 파일을 합치는 비용을 계산하는 과정이 무언가 반복적이고, 이전에 계산한 내용이 사용되는 것을 알 수 있다.

4 개의 파일을 최소로 합치는 비용을 계산하려면

3 개의 파일을 최소로 합치는 비용을 알아야 하고

이를 위해서는 2개의 파일을 최소로 합치는 비용을 알아야 한다.

즉, 작은 문제로 계속 분할이 되는 구조이다.

이러한 상황은 DP 로 해결할 수 있다.

dp 테이블을 2차원으로 선언한다. 

dp[x][y] 라는 것의 의미는 x 번째부터 y 번째 까지 합치는 데 필요한 최소 비용을 의미한다.

x 부터 y 사이의 k 가 있다고 할 떄,

dp[x][y] 는 dp[x][k] + dp[k+1][y] + file[x]+...+file[k]+...+fike[y] 가 된다.

(작성 중)



