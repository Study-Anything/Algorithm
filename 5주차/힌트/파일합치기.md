단순하게 생각해보자.

파일의 개수가 n 개라면,

모든 경우의 수를 다 따져본다고 가정해보자.

그러면 n 개 중에서 2개를 고르고... n-1 개 중에서 2개를 고르고 ... 2 개 중에서 2 개를 고르게 되겠죠..?

그러면 nC2 + n-1C2 +...+ 2C2 ~= n^3 

그리고 n 의 최댓값은 500 이니까

O(500^3) = 125,000,000 이다.

별 문제가 없다면 1.5 초 이내에 겨우겨우 동작하는 프로그램이 만들어질 수는 있겠지만..!

사실 코테에서 시간 제한이 2초이면 보통 0.2~0.5 초 내에 동작이 가능하도록 설계한다고 한다.

또 우리는, 입출력도 많이 받아야 할텐데

예상보다 더 많은 시간복잡도가 소요될 수 있으므로 보수적으로 접근하는 게 맞다.

그러니까, 완전 탐색으로 푸는 것은 조금은 위험할 수 있겠다.

그러면 어떻게 풀 수 있을까?

## ⭐ 어려운 문제는 쉬운 문제로 바꿔서 생각해보면 인사이트를 얻을 가능성이 있다..!

파일의 개수가 4 개라고 치고 각각 A,B,C,D 라고 해보자.

그러면 어떤 경우의 수가 있을까..?

1. [A B] 를 합치고, [C D] 를 합치고, [A B] 와 [C D] 를 합칠 수 있겠다.

2. [B C] 를 합치고, [A D] 를 합치고, [B C] 와 [A D] 를 합칠 수 있다.

3. [A C] 를 합치고, [B D] 를 합치고, [A C] 와 [B D] 를 합칠 수 있다.

4. [A B] 를 합치고, [A B] 와 C 를 합치고, [A B C] 와 D 를 합쳐도 되겠다.

5. [C D] 를 합치고, [C D] 와 B 를 합치고, [B C D] 와 A 를 합쳐도 된다.

...


자, 모든 경우가 다 그런거는 아니지만

특히 4 번째 경우를 보면

[A B] 를 합치는 계산을 (가) 라고 하자.

그러면 [A B] 와 C 를 합칠 때 (가) 가 이용된다. -> 얘는 (나) 라고 하자.

그러면 [A B C] 와 D 를 합칠 때 (나) 가 이용된다.

즉, 반복된 연산을 하게 되는 경우가 종종 발생한다는 것이다.

반복된 연산이 있을 때 하나하나 다 계산하는 것은 O(N^3) 의 시간복잡도를 가질 것이다.

즉, 반복된 연산을 피해야 할 텐데...

이러한 경우에 반복된 연산의 결과 값을 다른 메모리에 저장하고,

반복된 연산이 필요하면 실제로 그 연산을 반복하는 것이 아닌 메모리에서 꺼내오는 방법을 많이 사용한다.

즉, 캐싱을 하자는 것이고

이는 알고리즘에서 다이나믹프로그래밍에서 말하는 메모이제이션이다.

파일을 합칠 때, 반복된 결과 값을 메모리에 저장해서 활용하면 이 문제를 해결할 수 있을 것이라고 짐작할 수 있겠다.

---

## ⭐ 이제 규칙을 조금 더 정확하게 표현해보자.

f(p, q) 라는 함수를 정의해보자.

f(p, q) 는 p 부터 q 까지의 파일을 합칠 때의 최소 비용이다.

즉, A B C D E 일때 f(0, 2) 는 A B C D 을 합치는 데에 최소 비용을 의미한다는 것이다.

일반화해서 생각해보면

f(p, q) = f(p, p) + f(p+1, q) 이거나 f(p, p+1) + f(p+2, q) 이거나 f(p, p+2) + f(p+3, q) ...

라는 것이다.

저 경우의 수 중 가장 작은 것이 우리가 원하는 답이 될 것이다.

또한 각각을 계산할 때, 중복된 연산이 있으면 기록하여 최적화를 할 수 있을 것이다.

자, 함수 형태를 보면 2차원이다..

즉, dp 테이블을 2차원으로 선언해야 한다.

```
f(p, q) 는 dp[p][q] 
```
---

A, B, C, D 라는 비용을 가지는 파일을 가지고 있다고 생각해보자.

하나의 파일만 있으면, 합칠 수 없으므로 비용이 0 이다.

![image](https://github.com/Study-Anything/Algorithm/assets/96612168/0d32cb3b-7fef-4fe3-bff4-97546f2ce757)

그러므로 위와 같이 대각선은 모두 0 이여야 할 것.

파일 두개를 합치는 비용은 단 하나의 경우 밖에 존재하지 않는다.

![image](https://github.com/Study-Anything/Algorithm/assets/96612168/ffeca4c0-c300-4c3c-84c7-08a375ed3b3a)

이제 저 파란 칸을 채워야 할 텐데,

![image](https://github.com/Study-Anything/Algorithm/assets/96612168/6468f8bb-3255-475d-837b-806981c3af04)

어떻게 해야 할까

파란칸은 A B C 를 합치는 최소 비용을 의미한다.
경우의 수는 [AB][C] 와 [A][BC] 와 [AC][

.. 작성중 ...
